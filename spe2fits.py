#!/usr/bin/env python3

"""
Convert .SPE file generated by WinViewer to FITS

ref: https://github.com/kaseyrussell/python_misc_modules.git
ref: http://scipy-cookbook.readthedocs.io/items/Reading_SPE_files.html<Paste>
ref: ftp://ftp.piacton.com/Public/Software/Examples/datatypes/WINHEAD.TXT

NOTE little-endian assumed

"""

import sys
import re
import struct

import numpy as np
from astropy.io import fits

#class SpeConverter:
#    pass

# If FITS header changed, Major.Minor version will be changed
VERSION = "0.1.0"
AUTHOR = "JerryJia <jiajerry@mail.ustc.edu.cn>"

SPE_consts = {}
SPE_consts['HDRNAMEMAX' ] = 120    # Max char str length for file name
SPE_consts['USERINFOMAX'] = 1000   # User information space
SPE_consts['COMMENTMAX' ] = 80     # User comment string max length (5 comments)
SPE_consts['LABELMAX'   ] = 16     # Label string max length
SPE_consts['FILEVERMAX' ] = 16     # File version string max length
SPE_consts['DATEMAX'    ] = 10     # String length of file creation date string as ddmmmyyyy\0
SPE_consts['ROIMAX'     ] = 10     # Max size of roi array of structures
SPE_consts['TIMEMAX'    ] = 7      # Max time store as hhmmss\0

SPE_DATA_OFFSET = 4100 # That is, header length

# for key 'datatype'
SPE_DATATYPE = {
    0: 'f', #'float' 4
    1: 'l', #'long' 4
    2: 'h', #'short' 2
    3: 'H', #'unsigned short' 2
}

STRUCT_TO_NUMPY = {
    'f': np.float32,
    'l': np.int32,
    'h': np.short,
    'H': np.ushort,
}

#  char
#  short
#  float
#  long
#  double
#  BYTE = unsigned char
#  WORD = unsigned short
#  DWORD = unsigned long
SPE_TYPE_FMT = {
    'char': 'c',
    'short': 'h',
    'float': 'f',
    'long': 'l',
    'double': 'd',
    'BYTE': 'B',
    'WORD': 'H',
    'DWORD': 'L',
    }

def fetchLength(lenStr):
    try:
        length = int(SPE_consts.get(lenStr, lenStr))
    except:
        length = 1
    return length

def parseFormat(type_, key):
    """ parse format with type and key
    convert a[b] to b'fmt'
    convert a[b][c] to b * cs if type is char
    return: ('fmt',   'counts',  'length', 'key')
    #0 char a[b][c] -> ('<c>s',  <b>,   <c>, 'a')
    #1 char a[b]    -> ('<b>s',  1,     0,   'a')
    #2 type a[b]    -> ('<b><t>',1,     0,   'a')
             ( unpack will get tuple length > 1 )
    #3 type a       -> ('<t>',   1,     0,   'a')
    """
    # default is #3
    counts = 1
    length = 0 # only not zero for a[b][c] (length will be c)
    got = key.partition('[') # a[b]:('a','[','b]')  a[b][c]:('a','[','b][c]')
    realKey, rest = got[0], got[2]
    fmt = SPE_TYPE_FMT.get(type_, 'c')
    if rest != '' and fmt == 'c': # #0 or #1
        fmt = 's'
        newgot = rest.partition(']') # ('b',']','') or ('b',']','[c]')
        length = fetchLength(newgot[0]) # 'b'
        if newgot[2] != '': # '[c]' #0
            counts = length # 'counts' is 'b'
            c_length = fetchLength(newgot[2][1:-1]) # '[c]' -> c
            fmt = str(c_length) + fmt # <c>s
            length = c_length # 'length' is 'c'
        else: # '' #1
            fmt = str(length) + fmt # <b>s
            length = 0
    elif rest != '': # #2
        fmt = rest.partition(']')[0] + fmt # 'b''fmt'
    return fmt, counts, length, realKey

# Some header to be added:  ROIinfo, type,
def loadHeadersDef(filename = "WINHEAD.TXT") -> [{}]:
    """ load/parse header defination file
    """
    import extractHeaderDesc as H
    headers = H.getHeaders(filename)
    return headers

def checkVal(val, fmt):
    if 's' in fmt:
        return val.decode().partition('\x00')[0]
    if 'c' in fmt and ord(val) == 0:
        return ''
    return val

def addToHeader(headerDict, headerData, key, offset=0, fmt='c', counts=1, length=0, comment=''):
    """ add new extracted data to header
    """
#    print(offset, key, fmt, counts, length)
    if counts == 1:
        val = struct.unpack_from(fmt, headerData, offset=offset)
        if len(val) > 1:
            for i in range(len(val)):
                newkey = "{key}_{index}".format(
                        key = key,
                        index = i,
                        )
                headerDict[newkey] = (checkVal(val[i], fmt), comment)
        else:
            headerDict[key] = (checkVal(val[0], fmt), comment)
    else:
        for i in range(counts):
            val = struct.unpack_from(fmt, headerData, offset=i*length+offset)
            newkey = "{key}_{index}".format(
                    key = key,
                    index = i,
                    )
            headerDict[newkey] = (checkVal(val[0], fmt), comment)

def loadSpeHeader(fileObj, headerDef):
    """ load and save .SPE file header
    fileObj:  file handler(opened file, can be read())
    headerDef: [{}], keys: 'offset', 'type', 'key', 'comment'
    """
    #TODO check 'key', e.g. convert 'Comments[5][COMMENTMAX]' to array
    headerDict = {}
    fileObj.seek(0)
    headerData = fileObj.read(SPE_DATA_OFFSET)
    for header in headerDef:
        #print(header)
        key = header['key']
        offset = header['offset']
        type_ = header['type']
        comment = header['comment']
        fmt, counts, size, key = parseFormat(type_, key)
        addToHeader(headerDict, headerData, key,
                offset = offset,
                fmt = fmt,
                counts = counts,
                length = size,
                comment = comment,
                )
    return headerDict

SPE_IGNORE = {
        'pixel_position',
        'Spare',
        'Comments',
        'calib',
        'reserved',
        'polynom',
        'Spec',
        'PImax',
        'FlatField',
        }
def stripIgnore(speHeader):
    """ Remove some headers in .SPE file
    """
    keys = list(speHeader.keys())
#    for k in keys:
#        if speHeader[k][0] == '':
#            speHeader.pop(k)
    for key in keys:
        for toIgnore in SPE_IGNORE:
            if toIgnore in key and speHeader[key][0] in ('',0.0,0):
                speHeader.pop(key)

def renameHeaderKey(fitshdr, oldname, newname):
    try:
        fitshdr[newname] = (fitshdr[oldname], fitshdr.comments[oldname])
        fitshdr.pop(oldname)
    except:
        pass

def extractInfo(speHeader, fileObj):
    """ Extract information and construct FITS header from .SPE header
    """
    stripIgnore(speHeader)
    meta = {}
    meta['img_count'] = speHeader['NumFrames'][0]
    meta['xdim'], meta['ydim'] = speHeader['xdim'][0], speHeader['ydim'][0]
    meta['datatype'] = SPE_DATATYPE.get(speHeader['datatype'][0], 'f')
    fitshdr = fits.header.Header()
    for k, v in speHeader.items():
        fitshdr[k] = v
    renameHeaderKey(fitshdr, 'DetTemperature', 'TEMP')
#    fitshdr = speHeader.copy() # currently it is a copy
#    fitshdr['ADC_OFFSET'] = speHeader['ADCoffset']
#    fitshdr['ADC_RATE'] = speHeader['ADCrate']
#    fitshdr['ADC_RESOLUTION'] = speHeader['ADCresolution']
    return meta, fitshdr

def writeToFits(dataArr, name = "output.fits", fitshdr = None):
    """ save ndarry to fits file
    """
    print(dataArr, name, fitshdr)
    hdu = fits.PrimaryHDU(data = dataArr, header = fitshdr)
    hdu.writeto(name, clobber = True)

def loadSpeImg(outprefix, fileObj, metadict, fitshdr = None):
    """ load image data from .SPE file
    we assume that the file pointer is at the begining of img data
    outprefix: output filename's prefix
    fileObj: opened file object/handler
    metadict: dict with metadata
    fitshdr: fits header to write
    """
    print(outprefix, fileObj, metadict)
    datatype = metadict['datatype']
    nframes = metadict['img_count']
    xdim, ydim = metadict['xdim'], metadict['ydim']
    arr_size = xdim * ydim
    img_size = arr_size * struct.calcsize(datatype)
    fmt = str(arr_size) + datatype
    ndtype = STRUCT_TO_NUMPY[datatype]
    for i in range(nframes):
        data = fileObj.read(img_size)
        dataArr = np.array(
                struct.unpack(fmt, data),
                dtype = ndtype
                )
        writeToFits(dataArr.reshape((ydim, xdim)),
                name = "{}_x{:03}.fits".format(outprefix, i),
                fitshdr = fitshdr,
                )

def spe2fits(filename):
    fileObj = open(filename, "rb")
    SPE_header = loadSpeHeader(fileObj, loadHeadersDef())
    meta, fitshdr = extractInfo(SPE_header, fileObj)

    # Add additional header
    fitshdr['TOOLNAME'] = ('spe2fits ' + VERSION, "Tools to convert WinViewer .SPE to FITS")
    fitshdr['AUTHOR'] = (AUTHOR, "Tools' author")
    fitshdr['SPEFNAME'] = (filename, "original SPE filename")
    fitshdr['HEAD']    = ('PVCAM', 'Head model')
    matched = re.match('(.*)\.spe.*$', filename, flags = re.IGNORECASE)
    if matched is not None and matched.groups()[0] != '':
        guessPrefix = matched.groups()[0]
    else:
        guessPrefix = filename
    loadSpeImg(guessPrefix, fileObj, meta, fitshdr)
    fileObj.close()

if __name__ == '__main__':
    filename = sys.argv[1]
    spe2fits(filename)

